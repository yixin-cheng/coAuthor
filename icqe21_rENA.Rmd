---
title: "ICQE_20201_rENA"
author: "Yeyu Wang & Zach Swiecki"
date: "`r Sys.Date()`"
output: 
    html_document:
      toc: true
      toc_float: true

---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Getting Started

To get started, we load the `rENA` library.  If it is not already installed, you will have run `install.packages('rENA')` prior to loading the library. These examples are all written using the provided *RS.data* set that is packaged with `rENA`, which we load first.

```{r message=F, warning=F, paged.print=T}

rm(list=ls())
library(rENA)
data(RS.data)
```


Loading some other packages we might need later. Use `install.packages` if you do not have them.

```{r echo=F, message=F, warning=F}
library(dplyr)
```

# Identify Columns To Accumulate

Before running the `ena.accumulate.data` function, we need to first identify which columns of the data to use for our *units*, *conversation*, and *codes*.  There is also an optional *metadata* parameter which is for unit-specific data we wish to carry through the accumulation process and keep associated with the identified units.  The accumlation process requires individual dataframes for each of the respective parameters, so we will subset and preview the `RS.data` using the identified columns.

```{r }

units = RS.data[,c("Condition","UserName")]
head(units)

conversation = RS.data[,c("Condition","GroupName","ActivityNumber")]
head(conversation)

codeCols = c(
  'Data','Technical.Constraints','Performance.Parameters',
  'Client.and.Consultant.Requests','Design.Reasoning','Collaboration'
)
codes = RS.data[,codeCols]
head(codes)

# optional
meta = RS.data[,c("CONFIDENCE.Change",
                  "CONFIDENCE.Pre","CONFIDENCE.Post","C.Change")]
head(meta)
```

# Accumulation and set generation

The most basic form of an ENAset can be generated by passing along the result of calling the `ena.accumulate.data` function to `ena.make.set` which performs a dimensional reduction on the connection counts and runs an optimization to routine to decide the positions of the network nodes in the reduced space.

We can combine the accumulation and set generation steps using pipes `%>%` from the `dplyr` package. Pipes send the output of one function into the first parameter of the subsequent function. 

```{r}
#with pipes
set = 
  ena.accumulate.data(
  units = units,
  conversation = conversation,
  codes = codes,
  metadata = meta,
  window.size.back = 7
) %>%
  ena.make.set()
```

There is also a helper function called `ena` that lets you accumulate and make the set together

```{r,message=FALSE}
set = 
ena(
  data = RS.data,
  units = c("UserName","Condition", "GroupName"),
  conversation = c("Condition","GroupName"),
  codes = c('Data',
            'Technical.Constraints',
            'Performance.Parameters',
            'Client.and.Consultant.Requests',
            'Design.Reasoning',
            'Collaboration'),
  window.size.back = 7, 
  print.plots = FALSE,
  groupVar = "Condition",
  groups = c("FirstGame", "SecondGame"),
  networkMultiplier = 8
)
```
## Stanza options

The size of moving stanza window is one of the important model specification. To change stanza options, update the `window` parameter of the `ena.accumulate.data` function. The default is "MovingStanzaWindow". To run an infinite moving stanza window, set the `window.size.back` parameter to "INF". To run a whole conversation model, set `window` to "Conversation. 

Here we use the `ena` helper function to make the set with different window options.

```{r, message= FALSE}
set_inf = ena(
  data = RS.data,
  units = c("UserName","Condition", "GroupName"),
  conversation = c("Condition","GroupName"),
  codes = c('Data',
            'Technical.Constraints',
            'Performance.Parameters',
            'Client.and.Consultant.Requests',
            'Design.Reasoning',
            'Collaboration'),
  window = "MovingStanzaWindow", ### update window option here
  window.size.back = "INF",
  print.plots = FALSE,
  groupVar = "Condition",
  groups = c("FirstGame", "SecondGame")
)



set_convo = ena(
  data = RS.data,
  units = c("UserName","Condition", "GroupName"),
  conversation = c("Condition","GroupName"),
  codes = c('Data',
            'Technical.Constraints',
            'Performance.Parameters',
            'Client.and.Consultant.Requests',
            'Design.Reasoning',
            'Collaboration'),
  window = "Conversation" ,  ### update window option here
  print.plots = FALSE,
  groupVar = "Condition",
  groups = c("FirstGame", "SecondGame")
)

```

# Plotting

Now that we have generated ENAset, we can think about plotting.  To do so, we first need to think about what it is we to plot or compare.  In this example, we will look at the two specific groups, defined in `RS.data` by the `Condition` column: "FirstGame" or relative novices and "SecondGame" or relative experts

## Plot Units In Each Group

We will start by plotting the units for each condition as a different color. Referencing back to the `set$points` we will subset the rows that are in each condition and plot each group of units individually (on the same plot), as a different color.

```{r echo=TRUE}
### Subset rotated points for the first condition
first.game.points = as.matrix(set$points$Condition$FirstGame)

### Subset rotated points for the second condition
second.game.points = as.matrix(set$points$Condition$SecondGame)

plot = ena.plot(set, scale.to = "points", title = "Groups of Units")  %>%
       ena.plot.points(points = first.game.points, colors = c("blue"))  %>%
       ena.plot.points(points = second.game.points, colors = c("red"))
plot$plot
```


## Plotting Means

Plotting the means of a group of units can be done using the `ena.plot.group` function and by passing the same set of points the function will calculate the mean to plot.  In this case we will define the color to match the units that we already plotted, along with a corresponding confidence interval.

```{r }
### Using the same plot object above, we will be able to plot the means 
### alongside their corresponding units.
plot = ena.plot(set, scale.to = "points", title = "Groups and Means")  %>%
       ena.plot.points(points = first.game.points, 
                       confidence.interval = "box", colors = c("blue"))  %>%
       ena.plot.points(points = second.game.points, 
                       confidence.interval = "box", colors = c("red"))  %>%
       ena.plot.group(point = first.game.points, 
                      colors =c("blue"), confidence.interval = "box")  %>%
       ena.plot.group(point = second.game.points, 
                      colors =c("red"), confidence.interval = "box")
plot$plot
```

## Plotting a Network

To plot a network, we will use the `ena.plot.network` function.  This function requires  the `network` parameter (a character vector of line weights).  

The line weights will come from `set$line.weights`, which we will subset by our two groups as we did while plotting the unit points.
```{r }
### Subset lineweights for FirstGame and Calculate the colMeans
first.game.lineweights = as.matrix(set$line.weights$Condition$FirstGame)

### Subset lineweights for SecondGame and Calculate the colMeans
second.game.lineweights = as.matrix(set$line.weights$Condition$SecondGame)
```

Next we calculate the mean networks for the two groups and the and subtracted network

```{r Calculate Means and Their Differences of Two Groups}
first.game.mean = as.vector(colMeans(first.game.lineweights))
second.game.mean = as.vector(colMeans(second.game.lineweights))

### Subtract the two sets of means, resulting in a vector with negative values
### indicatinag a stronger connection with the SecondGame, and positive values
### a stronger FirstGame connection
subtracted.mean = first.game.mean - second.game.mean

# View the first 5 elements to see the substraction
head(first.game.mean, 5)
head(second.game.mean, 5)
head(subtracted.mean, 5)
```

Here, we plot the mean network for the firstgame points
```{r Plot Network of Units in FirstGame}
#Plot subtracted network only
plot.first = ena.plot(set, title = "FirstGame")  %>%
             ena.plot.network(network = first.game.mean, colors = c("blue"))
plot.first$plot
```

and here the network for the secondgame points

```{r Plot Network of Units in SecondGame}
plot.second = ena.plot(set, title = "SecondGame")  %>% 
              ena.plot.network(network = second.game.mean, colors = c("red"))
plot.second$plot
```

And finally the subtracted network

```{r Plot a Subtracted Network}
plot.sub = ena.plot(set, title = "Subtracted")  %>%
           ena.plot.network(network = subtracted.mean *8, colors = c("blue","red"))
plot.sub$plot
```

## Plot Everything Together

Using pipes, we can plot points, means, and networks at the same time, or we can use the helper function `ena.plotter`

```{r }

#with pipes

plot = ena.plot(set, title = "Plot with Units and Network") %>% 
          ena.plot.points(points = first.game.points, colors = c("blue")) %>% 
          ena.plot.points(points = second.game.points, colors = c("red")) %>% 
          ena.plot.group(point = first.game.points, colors =c("blue"), 
                         confidence.interval = "box") %>% 
          ena.plot.group(point = second.game.points, colors =c("red"), 
                         confidence.interval = "box") %>%
          ena.plot.network(network = subtracted.mean *8, colors = c("blue","red"))

plot$plot

#with helper function

plot = ena.plotter(set,
                      points = T,
                      mean = T, 
                      network = T,
                      print.plots = F,
                      groupVar = "Condition",
                      groups = c("FirstGame","SecondGame"),
                      subtractionMultiplier = 8)

plot$plots$`FirstGame-SecondGame`

```
## Plot Aesthetics

In ENA plots, we can change (1) the title of a plot, (2) font, size and color of characters, (3) position of label. Let's take the previous plot as example. 

```{r }

#View code names to help with updating the positions
set$rotation$codes

#plot
plot = ena.plot(set, 
                ### Change the title of plot:
                title = "Plot with Units and Network",  
                ### Change the font of characters:
                font.family = "Courier New", 
                ### Change the font size of characters:
                font.size = 16, 
                ### Change the color of characters:
                font.color = "slateblue", 
                ### Change the dimension labels:
                dimension.labels = c("SVD1", "SVD2")
                ) %>% 
          ena.plot.points(points = first.game.points, colors = c("blue")) %>% 
          ena.plot.points(points = second.game.points, colors = c("red")) %>% 
          ena.plot.group(point = first.game.points, colors =c("blue"), 
                         confidence.interval = "box") %>% 
          ena.plot.group(point = second.game.points, colors =c("red"), 
                         confidence.interval = "box") %>%
          ena.plot.network(network = subtracted.mean *8, 
                           colors = c("blue","red"),
                           ### Change the position of node labels:
                           label.offset = c("left", "top", "right", 
                                            "right", "right", "bottom"), 
                           scale.weights = FALSE)

plot$plot
```

# Rotation Methods

There are three possible rotation methods to be specified in ENA: singular value decomposition, means rotation, and rotation into existing space. To change the rotation method, we need to manipulate the parameter in`ena.make.set`.

## Singular Value Decomposition (SVD)

The most basic ENA space is the one generated via SVD on the normalized and centered connection counts. Typically, units are plotted on the first two dimensions because these account for the most variance among the units. However, any SVD dimension can be chosen. 

```{r}
set$model$variance

# plotting original set with SVD 1 and 3

plot.alt = ena.plot(set, title = "Plot with Units and Network: Dims 1 & 3") %>% 
          ena.plot.points(points = first.game.points[,c(1,3)], colors = c("blue")) %>% 
          ena.plot.points(points = second.game.points[,c(1,3)], colors = c("red")) %>% 
          ena.plot.group(point = first.game.points[,c(1,3)], colors =c("blue"), 
                         confidence.interval = "box") %>% 
          ena.plot.group(point = second.game.points[,c(1,3)], colors =c("red"), 
                         confidence.interval = "box") %>%
          ena.plot.network(network = subtracted.mean *8, colors = c("blue","red"),
                           node.positions = set$rotation$nodes[,c(1,2,4)]) ### DON'T FORGET TO UPDATE THE NODE POSITIONS TOO


plot$plot
plot.alt$plot

```


## Means Rotation (MR)

Creating and plotting a means rotated set is fairly similar to a standard set, however we will define the rotation function along with the groups of rotated points that will be rotated along their means.  The **rENA** package comes with a function for means rotation, `ena.rotate.by.mean`, which is set as the `rotation.by` parameter of `ena.make.set`.  Along with the function, `rotation.params` is set as the parameters we want to pass along to the rotation function.  In the case of `ena.rotate.by.mean`, it expects `rotation.params` to be a `list` with two named elements, each containing a logical vector representing the rows of units to be included in particular group.

```{r }
## Save references to the two vectors for easier re-use
accum = ena.accumulate.data(
  units = units,
  conversation = conversation,
  codes = codes,
  metadata = meta,
  window.size.back = 7
) 
first.game = accum$meta.data$Condition == "FirstGame"
second.game = accum$meta.data$Condition == "SecondGame"

rotation.params = list(
  FirstGame = first.game, 
  SecondGame = second.game
)

setMeansRotated = ena.make.set(
  enadata = accum,                   # The previously run accumulation above
  rotation.by = ena.rotate.by.mean,  # Function provided by rENA
  rotation.params = rotation.params  # The defined paremeters for rotation
)


#with helper function
setMeansRotated = ena(
  data = RS.data,
  units = c("UserName","Condition", "GroupName"),
  conversation = c("Condition","GroupName"),
  codes = c('Data',
            'Technical.Constraints',
            'Performance.Parameters',
            'Client.and.Consultant.Requests',
            'Design.Reasoning',
            'Collaboration'),
  window.size.back = 7,
  print.plots = FALSE,
  groupVar = "Condition",
  mean = TRUE,
  groups = c("FirstGame", "SecondGame"),
  networkMultiplier = 8
)

```

```{r means-rotation}
#original set
plot$plot

# Means rotated
setMeansRotated$plots$`FirstGame-SecondGame`
```

## Projection: Rotation to Existing Space

To project the ENA scores/plotted points from one model to another, replace the `rotation.set` parameter of `ena.make.set`. Below, we make an "expert" model  and project the novice data into that space.

```{r}
#expert data
exp.data = RS.data %>% filter(Condition == "SecondGame")

#novice data
nov.data = RS.data %>% filter(Condition == "FirstGame")

#expert model
units_exp = exp.data[,c("Condition","UserName")]
conversation_exp = exp.data[,c("Condition","GroupName","ActivityNumber")]
codes_exp = exp.data[,codeCols]
meta_exp = exp.data[,c("CONFIDENCE.Change",
                  "CONFIDENCE.Pre","CONFIDENCE.Post","C.Change")]

set_exp = 
  ena.accumulate.data(
  units = units_exp,
  conversation = conversation_exp,
  codes = codes_exp,
  metadata = meta_exp,
  window.size.back = 7,
) %>%
  ena.make.set()

head(set_exp$rotation$rotation.matrix)
head(set_exp$model$points.for.projection)

#novice model
units_nov = nov.data[,c("Condition","UserName")]
conversation_nov = nov.data[,c("Condition","GroupName","ActivityNumber")]
codes_nov = nov.data[,codeCols]
meta_nov = nov.data[,c("CONFIDENCE.Change",
                  "CONFIDENCE.Pre","CONFIDENCE.Post","C.Change")]

set_nov = 
  ena.accumulate.data(
  units = units_nov,
  conversation = conversation_nov,
  codes = codes_nov,
  metadata = meta_nov,
  window.size.back = 7,
) %>%
  ena.make.set(rotation.set = set_exp$rotation) 


# plot expert model (what we projected into) Using plotting wrapper to save time

plot_exp = ena.plotter(set_exp,
                        points = T,
                        mean = T, 
                        network = T,
                        print.plots = F
                       )

# plot test model (points from test model in training model space)
plot_nov = ena.plotter(set_nov,
                        points = T,
                        mean = T, 
                        network = T,
                        print.plots = F)


```

```{r proj-plot}
#compare plots
plot_exp$plots[[1]]
plot_nov$plots[[1]]

```

# Subsequent models

## Hypothesis tests

It is often useful to use the outputs of ENA models in subsequent analyses. The most commonly used outputs are the ENA scores/plotted points. For example, we can test for statistical differences between groups in our data in terms of their ENA scores. Here we ask: are the connections that one group makes statistically different than those made by another group. We can also use ENA scores to predict outcome variables. Here, we ask: are the kinds of connections that our units of analysis made predictive of an outcome. In the example below, we use a students t-Test and a non-parametric test to test for differences between the first and second game groups. 

```{r}
# subset points for test for differences between the points of two groups
first_points_d1 = as.matrix(set$points$Condition$FirstGame)[,1]
second_points_d1 = as.matrix(set$points$Condition$SecondGame)[,1]

first_points_d2 = as.matrix(set$points$Condition$FirstGame)[,2]
second_points_d2 = as.matrix(set$points$Condition$SecondGame)[,2]

# run t-Tests 
t_test_d1 = t.test(first_points_d1, second_points_d1)
t_test_d2 = t.test(first_points_d2, second_points_d2)

t_test_d1
t_test_d2

#non parametric tests

w_test_d1 = wilcox.test(first_points_d1, second_points_d1)
w_test_d2 = wilcox.test(first_points_d2, second_points_d2)

w_test_d1
w_test_d2

```

## Regression

Here, we use linear regression to test whether ENA scores on the first two dimensions are predictive of an outcome variable--in this case change in confidence in engineering skills.

```{r}
# make ENA set 
set = 
  ena.accumulate.data(
  units = units,
  conversation = conversation,
  codes = codes,
  metadata = meta,
  window.size.back = 7
) %>%
  ena.make.set()


# set up data for regression 
regression_data = set$points
regression_data$CONFIDENCE.Change = as.numeric(regression_data$CONFIDENCE.Change)

head(regression_data)
```

```{r}
# run regression of confidence change score on ENA scores on first two dimensions
condition_regression = lm(CONFIDENCE.Change ~ SVD1 + SVD2, 
                          data = regression_data, 
                          na.action = na.omit)
summary(condition_regression)

```

## Mixed Models

In many cases, the data we wish to model using ENA has a *nested* structure. 
Examples of nested structure include individuals grouped within teams or classrooms. 
Many statistical techniques assume *independent* observations. When data is nested, 
however, this assumption may be violated because the individuals within the same group
may influence one another. In other cases, it may be appropriate to control for 
the nesting variable when estimating effects, for example when individuals are 
in classrooms lead by different teachers. 

Whether the dependence among data points introduced by nesting is strong enough 
to consider can be tested by calculating the *intraclass correlation coefficient* (ICC). 
The ICC measures the similarity of data points within groups. 
It ranges from 0 to 1 with higher values indicating that the data 
points are more similar. If the ICC is significantly different from 0, the effect of 
the nesting should be accounted for when modeling the data.

One way to model nested data is by using *mixed-effects models*. These models 
are called mixed effects because they include two kinds of predictors: fixed 
effects and random effects. Fixed effects estimate separate values of the variable
with no relationship assumed between the levels. Random effects estimate separate
values of the variable as if they were randomly drawn from the same population. 
In practice, fixed effects are the variables used most often in regression models,
while random effects are grouping variables whose levels we can assume are drawn from 
some larger population.

To implement a mixed model we use `lmer`. The example below demonstrates a 
mixed model of the first game students from `RS.data`. Here, we regress the
ENA score of the students on the first dimension on two fixed effects that 
measure how dissimilar the patterns of connections that individuals made are to
the connections made by their teammates. The group that individuals were on is 
modeled as a random effect using the `lmer` syntax `(1|GroupName)`.

You can find an excellent overview of mixed-effects modeling here: https://bookdown.org/steve_midway/DAR/random-effects.html (Chapter 9). 

```{r mixed, message=FALSE}
#load libraries
library(ICC)
library(lmerTest)
#load data for example
mixed.dat = read.csv("/Users/zswi0001/Rprojects/icqe21_workshop/hlm.ex.csv")#update path
#view
head(mixed.dat)
#ICC
ICCest(x = GroupName, y = MR1, data = mixed.dat)
#fit model
mixed.mod = lmer(MR1 ~ dissimilarity + dissimilarity.mean + (1|GroupName),data = mixed.dat)

summary(mixed.mod)

```

# Extras

## Normalization

`ena.make.set` normalizes the adjacency vectors by default. To skip the normalization, supply the built in function `fun_skip_sphere_norm` to the norm.by parameter of `ena.make.set`. You can also supply a custom normalization function to this parameter if you'd like.
```{r}
set_no_norm = 
  ena.accumulate.data(
  units = units,
  conversation = conversation,
  codes = codes,
  metadata = meta,
  window.size.back = 7
) %>%
  ena.make.set(norm.by = fun_skip_sphere_norm)  # change the norm function here

```

## Weighted Models

To run a weighted model, update the `weight.by` parameter of the `ena.accumulate.data` function. For a product model, set `weight.by` to "product". For a square root weighted model, set `weight.by` to "sqrt". You can also supply your own function to `weight.by, if you'd like. 

```{r}
set = 
  ena.accumulate.data(
  units = units,
  conversation = conversation,
  codes = codes,
  metadata = meta,
  window.size.back = 7,
) %>%
  ena.make.set()

set_weighted = 
  ena.accumulate.data(
  units = units,
  conversation = conversation,
  codes = codes,
  metadata = meta,
  window.size.back = 7,
  weight.by = "product"  #sqrt  # function(x) { log(x + 1) }
) %>%
  ena.make.set()

## view differences in connections counts between weighted and non weighted models

head(set$connection.counts)
head(set_weighted$connection.counts)

```

## Trajectories

To run trajectory models, update the `model` paramater of the `ena.accumulate.data` function. For an accumulated trajactory, set the parameter to "A". For a separate trajectory, set it to "S". To plot trajectories, use the `ena.plot.trajectory` function.

```{r}
# make trajectory set 
accum_traj = 
  ena.accumulate.data(
  units = units,
  conversation = conversation,
  codes = codes,
  metadata = meta,
  window.size.back = 7,
  model = "A"
) 
  
set_traj = ena.make.set(accum_traj)

# create a dataframe of the ENA scores on the first dimension 
#and the conversation numbers on the second dimension 
dim.by.activity = cbind(
    as.matrix(set_traj$points)[,1],
    set_traj$trajectories$ActivityNumber * 0.015
)

# plot trajectories 
plot_traj = ena.plot(set_traj) %>% ena.plot.trajectory(
  points = dim.by.activity,
  names = unique(set_traj$trajectories$ENA_UNIT),
  by = set_traj$trajectories$ENA_UNIT,
  labels = ""
)

plot_traj
```


It can be useful to include the network on plot to make it easier interpret what trajectory changes mean. Here we set up the subtracted network for the two groups in our data and plot the trajectory position on the x axis
```{r}

#add network_nodes and scale down conversation dimension for easier interpretation

first.game.lineweights = as.matrix(set_traj$line.weights$Condition$FirstGame)
first.game.mean = colMeans(first.game.lineweights)
second.game.lineweights = as.matrix(set_traj$line.weights$Condition$SecondGame)
second.game.mean = colMeans(second.game.lineweights)
subtracted.network = first.game.mean - second.game.mean


plot_traj = ena.plot(set_traj) %>%
       ena.plot.network(network = subtracted.network, legend.name="Network") %>%
       ena.plot.trajectory(points = dim.by.activity, 
                           names = unique(set_traj$trajectories$ENA_UNIT),
                           by = set_traj$trajectories$ENA_UNIT,
                           labels = "")

plot_traj


```

