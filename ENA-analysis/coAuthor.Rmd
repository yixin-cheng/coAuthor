---
title: "coAuthor"
author: "Goldenfish"
date: "`r Sys.Date()`"
output: 
    html_document:
      toc: true
      toc_float: true

---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Getting Started

To get started, we load the `rENA` library.  If it is not already installed, you will have run `install.packages('rENA')` prior to loading the library. These examples are all written using the provided *RS.data* set that is packaged with `rENA`, which we load first.

```{r message=F, warning=F, paged.print=T}

rm(list=ls())
library(rENA)
library(readr)
data1 <- read_csv('ena_update_worker.csv',show_col_types = FALSE)
data1$user = ifelse(data1$eventSource == "user",1,0)
data1$gpt = ifelse(data1$eventSource == "user",0,1)
head(data1)
```


Loading some other packages we might need later. Use `install.packages` if you do not have them.

```{r echo=F, message=F, warning=F}
library(dplyr)
```

# Identify Columns To Accumulate

Before running the `ena.accumulate.data` function, we need to first identify which columns of the data to use for our *units*, *conversation*, and *codes*.  There is also an optional *metadata* parameter which is for unit-specific data we wish to carry through the accumulation process and keep associated with the identified units.  The accumlation process requires individual dataframes for each of the respective parameters, so we will subset and preview the `RS.data` using the identified columns.

```{r }

units = data1[,c("sessionId", "workerId")]
head(units)

conversation = data1[,c("sessionId", 
                        #"sentIndex", 
                        "workerId")]
head(conversation)

codeCols = c(
  'compose', 
  #'insert', 
  'delete', 
  #'revise', 
  'relocate',
  'reflect', 
  'seekSugg', 
  'acceptSugg', 
  'dismissSugg', 
  'lowModification',
   'highModification'#,
  #"user", #include this code
  #"gpt" #include this code
  #reviseSugg
)
codes = data1[,codeCols]
head(codes)

#mask = 

# optional
meta = data1[,c("genre",
                "highTemp")]
head(meta)
```

# Accumulation and set generation

The most basic form of an ENAset can be generated by passing along the result of calling the `ena.accumulate.data` function to `ena.make.set` which performs a dimensional reduction on the connection counts and runs an optimization to routine to decide the positions of the network nodes in the reduced space.

We can combine the accumulation and set generation steps using pipes `%>%` from the `dplyr` package. Pipes send the output of one function into the first parameter of the subsequent function. 

```{r}
#with pipes
set = 
  ena.accumulate.data(
  units = units,
  conversation = conversation,
  codes = codes,
  metadata = meta,
  #mask = mask,
  window.size.back = 2 # set to 1 if sent_index is included
) %>%
  ena.make.set()
```


```{r}
network = as.matrix(set$line.weights)
mean_network = colMeans(network)

p = ena.plot(set,title = "Overall Mean Network") %>%
  ena.plot.network(mean_network * 1,colors = "black")

p
```


## Plotting Means

Plotting the means of a group of units can be done using the `ena.plot.group` function and by passing the same set of points the function will calculate the mean to plot.  In this case we will define the color to match the units that we already plotted, along with a corresponding confidence interval.

```{r }
creat_pts = as.matrix(set$points$genre$creative)
arg_pts = as.matrix(set$points$genre$argumentative)

creat_net = colMeans(as.matrix(set$line.weights$genre$creative))
arg_net = colMeans(as.matrix(set$line.weights$genre$argumentative))

plot = ena.plot(set, scale.to = "points", title = "Creative vs Argumentative")  %>%
       #ena.plot.points(points = creat_pts,
                      # confidence.interval = "box", colors = c("blue"))  %>%
       #ena.plot.points(points = arg_pts,
                       #confidence.interval = "box", colors = c("red"))  %>%
       ena.plot.group(point = creat_pts,
                      colors =c("blue"), confidence.interval = "none")  %>%
       ena.plot.group(point = arg_pts,
                      colors =c("red"), confidence.interval = "none") %>% 
       ena.plot.network(network = creat_net - arg_net *3,colors = c("blue","red") )
plot$plot
```


## Means Rotation (MR)

Creating and plotting a means rotated set is fairly similar to a standard set, however we will define the rotation function along with the groups of rotated points that will be rotated along their means.  The **rENA** package comes with a function for means rotation, `ena.rotate.by.mean`, which is set as the `rotation.by` parameter of `ena.make.set`.  Along with the function, `rotation.params` is set as the parameters we want to pass along to the rotation function.  In the case of `ena.rotate.by.mean`, it expects `rotation.params` to be a `list` with two named elements, each containing a logical vector representing the rows of units to be included in particular group.

```{r }
## Save references to the two vectors for easier re-use
# accum = ena.accumulate.data(
#   units = units,
#   conversation = conversation,
#   codes = codes,
#   metadata = meta,
#   window.size.back = 7
# ) 
# first.game = accum$meta.data$Condition == "FirstGame"
# second.game = accum$meta.data$Condition == "SecondGame"
# 
# rotation.params = list(
#   FirstGame = first.game, 
#   SecondGame = second.game
# )
# 
# setMeansRotated = ena.make.set(
#   enadata = accum,                   # The previously run accumulation above
#   rotation.by = ena.rotate.by.mean,  # Function provided by rENA
#   rotation.params = rotation.params  # The defined paremeters for rotation
# )
# 
# 
# #with helper function
# setMeansRotated = ena(
#   data = RS.data,
#   units = c("UserName","Condition", "GroupName"),
#   conversation = c("Condition","GroupName"),
#   codes = c('Data',
#             'Technical.Constraints',
#             'Performance.Parameters',
#             'Client.and.Consultant.Requests',
#             'Design.Reasoning',
#             'Collaboration'),
#   window.size.back = 7,
#   print.plots = FALSE,
#   groupVar = "Condition",
#   mean = TRUE,
#   groups = c("FirstGame", "SecondGame"),
#   networkMultiplier = 8
# )

```

```{r means-rotation}
#original set
# plot$plot
# 
# # Means rotated
# setMeansRotated$plots$`FirstGame-SecondGame`
```


# Subsequent models


## Regression



```{r}

mod = lm(SVD1 ~ genre + workerId, data = set$points)
summary(mod)
```

```{r}
library(lmerTest)

mod.2 = lmerTest::lmer(SVD1 ~ genre + (1|workerId), data = set$points)
summary(mod.2)
```

## Mixed Models

In many cases, the data we wish to model using ENA has a *nested* structure. 
Examples of nested structure include individuals grouped within teams or classrooms. 
Many statistical techniques assume *independent* observations. When data is nested, 
however, this assumption may be violated because the individuals within the same group
may influence one another. In other cases, it may be appropriate to control for 
the nesting variable when estimating effects, for example when individuals are 
in classrooms lead by different teachers. 

Whether the dependence among data points introduced by nesting is strong enough 
to consider can be tested by calculating the *intraclass correlation coefficient* (ICC). 
The ICC measures the similarity of data points within groups. 
It ranges from 0 to 1 with higher values indicating that the data 
points are more similar. If the ICC is significantly different from 0, the effect of 
the nesting should be accounted for when modeling the data.

One way to model nested data is by using *mixed-effects models*. These models 
are called mixed effects because they include two kinds of predictors: fixed 
effects and random effects. Fixed effects estimate separate values of the variable
with no relationship assumed between the levels. Random effects estimate separate
values of the variable as if they were randomly drawn from the same population. 
In practice, fixed effects are the variables used most often in regression models,
while random effects are grouping variables whose levels we can assume are drawn from 
some larger population.

To implement a mixed model we use `lmer`. The example below demonstrates a 
mixed model of the first game students from `RS.data`. Here, we regress the
ENA score of the students on the first dimension on two fixed effects that 
measure how dissimilar the patterns of connections that individuals made are to
the connections made by their teammates. The group that individuals were on is 
modeled as a random effect using the `lmer` syntax `(1|GroupName)`.

You can find an excellent overview of mixed-effects modeling here: https://bookdown.org/steve_midway/DAR/random-effects.html (Chapter 9). 

```{r mixed, message=FALSE}
#load libraries
library(ICC)
library(lmerTest)
#load data for example
mixed.dat = read.csv("/Users/zswi0001/Rprojects/icqe21_workshop/hlm.ex.csv")#update path
#view
head(mixed.dat)
#ICC
ICCest(x = GroupName, y = MR1, data = mixed.dat)
#fit model
mixed.mod = lmer(MR1 ~ dissimilarity + dissimilarity.mean + (1|GroupName),data = mixed.dat)

summary(mixed.mod)

```

# Extras


## Trajectories

To run trajectory models, update the `model` paramater of the `ena.accumulate.data` function. For an accumulated trajactory, set the parameter to "A". For a separate trajectory, set it to "S". To plot trajectories, use the `ena.plot.trajectory` function.

```{r}
# make trajectory set 
# accum_traj = 
#   ena.accumulate.data(
#   units = units,
#   conversation = conversation,
#   codes = codes,
#   metadata = meta,
#   window.size.back = 7,
#   model = "A"
# ) 
#   
# set_traj = ena.make.set(accum_traj)
# 
# # create a dataframe of the ENA scores on the first dimension 
# #and the conversation numbers on the second dimension 
# dim.by.activity = cbind(
#     as.matrix(set_traj$points)[,1],
#     set_traj$trajectories$ActivityNumber * 0.015
# )
# 
# # plot trajectories 
# plot_traj = ena.plot(set_traj) %>% ena.plot.trajectory(
#   points = dim.by.activity,
#   names = unique(set_traj$trajectories$ENA_UNIT),
#   by = set_traj$trajectories$ENA_UNIT,
#   labels = ""
# )
# 
# plot_traj
```


It can be useful to include the network on plot to make it easier interpret what trajectory changes mean. Here we set up the subtracted network for the two groups in our data and plot the trajectory position on the x axis
```{r}

#add network_nodes and scale down conversation dimension for easier interpretation

# first.game.lineweights = as.matrix(set_traj$line.weights$Condition$FirstGame)
# first.game.mean = colMeans(first.game.lineweights)
# second.game.lineweights = as.matrix(set_traj$line.weights$Condition$SecondGame)
# second.game.mean = colMeans(second.game.lineweights)
# subtracted.network = first.game.mean - second.game.mean
# 
# 
# plot_traj = ena.plot(set_traj) %>%
#        ena.plot.network(network = subtracted.network, legend.name="Network") %>%
#        ena.plot.trajectory(points = dim.by.activity, 
#                            names = unique(set_traj$trajectories$ENA_UNIT),
#                            by = set_traj$trajectories$ENA_UNIT,
#                            labels = "")
# 
# plot_traj
# 

```

